//https://github.com/utopiat-ire/AtCoder.Produire
※コンパイル
※コンソール
コンソールから受け取って「 」で区切って{【N:整数】,【M:整数】}とみなす
フローという最大フロー(N*M+2)を作る

【グリッド:文字列の配列の配列】={}
N回繰り返す
	コンソールから受け取って1文字ずつ区切って内容とする
	内容をグリッドへ加える
そして

【s】=M*N
【t】=M*N+1
【i】に0からN-1まで繰り返す
	【j】に0からM-1まで繰り返す
		グリッド(i+1)(j+1)が「#」でなければ
			(i+j)%2が0なら
				フローにsからi*M+jまで1だけ加える
			他なら
				フローにi*M+jからtまで1だけ加える
			そして
		そして
	そして
そして

iに0からN-1まで繰り返す
	jに0からM-1まで繰り返す
		グリッド(i+1)(j+1)が「#」または(i+j)%2が0でないなら続ける
		【st】=i*M+j
		jが1以上かつグリッド(i+1)(j)が「.」なら
			フローにstからst-1まで1だけ加える
		そして
		iが1以上かつグリッド(i)(j+1)が「.」なら
			フローにstからst-Mまで1だけ加える
		そして
		i+1がN未満かつグリッド(i+2)(j+1)が「.」なら
			フローにstからst+Mまで1だけ加える
		そして
		j+1がM未満かつグリッド(i+1)(j+2)が「.」なら
			フローにstからst+1まで1だけ加える
		そして
	そして
そして
フローをsからtへ流してコンソールに出力して改行

フローの辺一覧を【要素:整数の配列】にそれぞれ繰り返す
	要素(1)がsまたは要素(2)がtまたは要素(4)が0なら続ける
	【fromR:整数】=(要素(1)￥M)
	【fromC:整数】=要素(1)%M
	【toR:整数】=(要素(2)￥M)
	【toC:整数】=要素(2)%M
	[(要素(1)-要素(2))の絶対値が1でない]またはMが1なら
		グリッド(fromRとtoRで小さい方+1)(fromC+1)=「v」
		グリッド(fromRとtoRで大きい方+1)(fromC+1)=「^」
	他なら
		グリッド(fromR+1)(fromCとtoCで小さい方+1)=「>」
		グリッド(fromR+1)(fromCとtoCで大きい方+1)=「<」
	そして
そして

グリッドを行にそれぞれ繰り返す
	行を繋げたものをコンソールに出力して改行
そして

最大フローとは
	-n:整数
	-グラフ:整数の配列の配列の配列
	-位置:整数の配列の配列={}

	はじめ(n)の手順
		このnは、n
		【数】に1からnまで繰り返す
			グラフ(数)は{}
		そして
	終わり
	自分に【from:整数】から【to:整数】まで【cap:整数】だけ、加える手順
		【m】は、位置の個数
		位置に{from,グラフ(from+1)の個数}を加える
		グラフ(from+1)に{to,グラフ(to+1)の個数,cap}を加える
		グラフ(to+1)に{from,グラフ(from+1)の個数-1,0}を加える
		mを返す
	終わり
	
	自分を【s:整数】から【t:整数】へ〈【リミット:整数】まで〉、流す手順
		リミット=2147483647
		【レベル:整数の配列】は{}
		
		bfsは『
			【数】に1からnまで繰り返す
				レベル(数)は-1
			そして
			レベル(s+1)は0
			queというキューを作る
			queにsを入れる
			queの要素数が0より大きい間繰り返す
				queから取り出して【v:整数】とする
				グラフ(v+1)をeにそれぞれ繰り返す
					e(3)が0またはレベル(e(1)+1)が0以上なら続ける
					レベル(e(1)+1)は、レベル(v+1)+1
					e(1)がtならレベルを返す
					queへe(1)を入れる
				そして
			そして
		』
		dfsは『
			それを{【v:整数】,【up:整数】}とみなす
			vがsならupを返す
			【res:整数】=0
			【i】に0から(グラフ(v+1)の個数-1)まで繰り返す
				【e】=グラフ(v+1)(i+1)
				【re】=グラフ(e(1)+1)(e(2)+1)
				レベル(v+1)がレベル(e(1)+1)以下またはre(3)が0なら続ける
				{e(1),((up-res)とre(3)で小さい方)}でdfsを実行して【d:整数】とする
				dが0以下なら続ける
				e(3)=e(3)+d
				re(3)=re(3)-d
				res=res+d
				resがupなら出る
			そして
			resを返す
		』
		【flow:整数】=0
		flowがリミット未満の間繰り返す
			bfsを実行したもの
			レベル(t+1)が-1なら出る
			flowがリミット未満の間繰り返す
				{t,リミット-flow}でdfsを実行して【f:整数】とする
				fが0なら出る
				flow=flow+f
			そして
		そして
		flowを返す
	終わり
	【n:整数】の、辺状態の手順
		【e】=グラフ(位置(n)(1)+1)(位置(n)(2)+1)
		【re】=グラフ(e(1)+1)(e(2)+1)
		{位置(n)(1),e(1),e(3)+re(3),re(3)}を返す
	終わり
	辺一覧の手順
		【結果】={}
		【数】に1から位置の個数まで繰り返す
			数の辺状態を結果に加える
		そして
		結果を返す
	終わり
終わり

【A:整数】と【B:整数】で小さい方の手順
	AがBより小さければAを返す
	Bを返す
終わり
【A:整数】と【B:整数】で大きい方の手順
	AがBより大きければAを返す
	Bを返す
終わり
