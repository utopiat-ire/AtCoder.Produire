//https://github.com/utopiat-ire/AtCoder.Produire
※コンソール
※コンパイル
コンソールから受け取って「 」で区切って{【N：整数】,【M：整数】}とみなす
コンソールから受け取って「 」で区切って【A：長整数の配列】とする
コンソールから受け取って「 」で区切って【B：長整数の配列】とする

Cとして畳込みを作る
Cのmod=998244353
結果は、CでAとBを畳み込むその1
結果を「 」で繋げたものをコンソールへ出力する

畳込みとは
	+mod:長整数
	【自分】で【a:長整数の配列】と【b:長整数の配列】を畳み込むその1手順:長整数の配列形
		【n】は、aの個数
		【m】は、bの個数
		【解答:長整数の配列形】
		【i:長整数】
		nが0またはmが0なら{}を返す
		nが60以下またはmが60以下なら
			解答という長整数の配列(n+m-1)を作る
			iに1からnまで繰り返す
				【j】に1からmまで繰り返す
					解答(i+j-1)=解答(i+j-1)+(a(i)*b(j))%mod
					解答(i+j-1)=解答(i+j-1)%mod
				そして
			そして
			解答を返す
		そして
		【z:長整数】は(1<<ceil_log2(n+m-1))
		iをnからz-1まで増やしながら繰り返す
			a#iは0
		そして
		iをmからz-1まで増やしながら繰り返す
			b#iは0
		そして
		【g】=原始根(mod)
		【es】という長整数の配列(30)を作る
		【ies】という長整数の配列(30)を作る
		【sum_e】という長整数の配列(30)を作る
		【sum_ie】という長整数の配列(30)を作る
		【cnt2】=NTZ(mod-1)
		【e】=pow_mod(g,(mod-1)>>cnt2,mod)
		【ie】=mul_inv(e,mod)
		iをcnt2から2まで減らしながら繰り返す
			es#[i-2]=e
			ies#[i-2]=ie
			e=e*e%mod
			ie=ie*ie%mod
		そして
		【now】=1
		iを0からcnt2-2-1まで増やしながら繰り返す
			sum_e#i=(es#[i]*now)%mod
			now=(now*ies#i)%mod
		そして
		now=1
		iを0からcnt2-2-1まで増やしながら繰り返す
			sum_ie#i=(ies#[i]*now)%mod
			now=(now*es#[i])%mod
		そして

		a=butterfly(a,sum_e)
		b=butterfly(b,sum_e)
		iに1からzまで繰り返す
			a(i)=a(i)*b(i)%mod
		そして
		a=butterfly_inv(a,sum_ie)
		【iz】=mul_inv(z,mod)
		解答={}
		iに1からn+m-1まで繰り返す
			解答(i)=((a(i)+mod)*iz)%mod
		そして
		解答を返す
	終わり
	【自分】"にて"【a:整数の配列】と【b:整数の配列】で畳み込むその2手順:長整数の配列形
		【n】は、aの個数
		【m】は、bの個数
		【MOD1】=754974721
		【MOD2】=167772161
		【MOD3】=469762049
		【M2M3】=MOD2*MOD3
		【M1M3】=MOD1*MOD3
		【M1M2】=MOD1*MOD2
		【M1M2M3】=M1M2*MOD3
		【i1】=inv_gcd(M2M3,MOD1)(1)
		【i2】=inv_gcd(M1M3,MOD2)(1)
		【i3】=inv_gcd(M1M2,MOD3)(1)
		【c1】=畳み込むその1(a,b,MOD1)
		【c2】=畳み込むその1(a,b,MOD2)
		【c3】=畳み込むその1(a,b,MOD3)
		【c】という長整数の配列(n+m)を作る
		【offset:長整数の配列】={0,0,M1M2M3,2* M1M2M3,3*M1M2M3}
		【i】に1からn*mまで繰り返す
			【x】=(c1(i)*i1)%MOD1*M2M3+
				(c2(i)*i2)%MOD2*M1M3+
				(c3(i)*i3)%MOD3*M1M2
			【diff】=(MOD1+c1(i)-x%MOD1)%MOD1
			x=x-offset(diff%5)
			c(i)=x
		そして
		cを返す
	終わり

	-inv_gcd(a:長整数,b:長整数)の手順:長整数の配列
		a=a%b
		(a=0)なら{b,0}を返す
		【s】=b
		【t】=a
		【m0】=0
		【m1】=1
		(t>0)の間、繰り返す
			【u】=s%t
			s=s-(t*u)
			m0=m0-(m1*u)
			sとtを交換
			m0とm1を交換
		そして
		(m0<0)なら
			m0=m0+b%s
		そして
		{s,m0}を返す
	終わり

	-butterfly(a:長整数の配列,sum_e:長整数の配列形)の手順:長整数の配列
		【n】=aの個数
		【h】=ceil_log2(n)
		【p】=1<<h
		【w】=1
		【ph】に1からhまで繰り返す
			p=p>>1
			【now】=1
			【offset】=0
			【add】=1<<(h-ph+1)
			【s】を0からw-1まで増やしながら繰り返す
				【i】を0からp-1まで増やしながら繰り返す
					a#(i+offset+p)=(a#(i+offset)-a#(i+offset+p)*now)%mod
					a#(i+offset)=(a#(i+offset)*2-a#(i+offset+p))%mod
				そして
				now=(now*(sum_e#[NTZ(~s)]))%mod
				offset=offset+add
			そして
			w=w<<1
		そして
		aを返す
	終わり

	-butterfly_inv(a:長整数の配列,sum_ie:長整数の配列形)の手順:長整数の配列
		【n】=aの個数
		【h】=ceil_log2(n)
		【w】=1<<h
		【p】=1
		【ph】をhから1まで減らしながら繰り返す
			w=w>>1
			【inow】=1
			【offset】=0
			【add】=1<<(h-ph+1)
			【s】を0からw-1まで増やしながら繰り返す
				【i】を0からp-1まで増やしながら繰り返す
					a#(i+offset)=(a#(i+offset)+a#(i+offset+p))%mod
					a#(i+offset+p)=((a#(i+offset)-(a#(i+offset+p)<<1))*inow)%mod
				そして
				【番号】=NTZ(~s)
				inow=(inow*(sum_ie#番号))%mod
				offset=offset+add
			そして
			p=p<<1
		そして
		aを返す
	終わり

	-bit_to_num(bits:整数)の手順:整数
		bits=(bits∧0x55555555)+(bits>>1∧0x55555555)
		bits=(bits∧0x33333333)+(bits>>2∧0x33333333)
		bits=(bits∧0x0f0f0f0f)+(bits>>4∧0x0f0f0f0f)
		bits=(bits∧0x00ff00ff)+(bits>>8∧0x00ff00ff)
		(bits∧0x0000ffff)+(bits>>16∧0x0000ffff)を返す
	終わり

	-NTZ(bits:長整数)の手順:長整数
		bit_to_num((~bits)∧(bits-1))を返す
	終わり

	-原始根(m:長整数)の手順:長整数
		m=2なら、1を返す
		m=167772161なら、3を返す
		m=469762049なら、3を返す
		m=754974721なら、11を返す
		m=998244353なら、3を返す
		【divs】=整数の配列(20)を作る
		divs#0=2
		【cnt】=1
		【x:長整数】=m-1\2
		(x%2=0)の間、繰り返す
			x=x>>1
		そして
		【i】=3
		(i*i <=x)の間、繰り返す
			i=i+2
			x%i=0なら
				cnt=cnt+1
				divs#cnt=i
				(x%i=0)の間、繰り返す
					x=x/i
				そして
			そして
		そして
		(x>1)なら
			cnt=cnt+1
			divs#[cnt]=x
		そして
		【g】=2
		繰り返す
			g=g+1
			【ok】=○
			iに0からcnt-1まで繰り返す
				(pow_mod(g, ((m-1)￥divs#i), m)=1)なら
					ok=×
					出る
				そして
			そして
			okならgを返す
		そして
		0を返す
	終わり

	-ceil_log2(x:整数)の手順:整数
		【t:長整数の配列】={
			0xFFFFFFFF00000000,
			0x00000000FFFF0000,
			0x000000000000FF00,
			0x00000000000000F0,
			0x000000000000000C,
			0x0000000000000002}
		【y】
		((x∧(x-1))=0)ならy=0
		他ならy=1
		【j】=32
		tを【値】にそれぞれ繰り返す
			((x∧値)=0)ならk=0
			そうでなければk=j
			y=y+k
			x=x>>k
			j=j>>1
		そして
		yを返す
	終わり
	-mul_inv(a:長整数,n:長整数)の手順:長整数
		nが0未満ならn=-n
		aが0未満ならa=n-(-a%n)
		【t:長整数】=0
		【nt:長整数】=1
		【r:長整数】=n
		【nr:長整数】=a
		nr<>0の間繰り返す
			【q:長整数】=r\nr
			【tmp】=t
			t=nt
			nt=tmp-q*nt
			tmp=r
			r=nr
			nr=tmp-q*nr
		そして
		rが1より大きければ
			エラーを発生
		他なら
			tが0未満ならt=t+n
			tを返す
		そして
	終わり
	-pow_mod(base:長整数,exp:整数,mod:整数)の手順:長整数
		【結果:長整数】=1
		exp>0の間繰り返す
			exp%2が1なら結果=(結果*base)%mod
			base=(base*base)%mod
			exp=exp￥2
		そして
		結果を返す
	終わり
終わり
