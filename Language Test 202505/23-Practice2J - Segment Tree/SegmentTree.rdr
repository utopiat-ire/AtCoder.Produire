//https://github.com/utopiat-ire/AtCoder.Produire
※コンソール
※コンパイル
コンソールから受け取って「 」で区切って{【N:整数】,【Q:整数】}とみなす
コンソールから受け取って「 」で区切って【A:整数の配列】とする
関数は『
	それを{【X:整数】,【Y:整数】}とみなす
	X>YならXを返す。他ならYを返す
』
ツリーというセグメントツリー(A, 関数, -1)を作る
Q回繰り返す
	コンソールから受け取って「 」で区切って{【T:整数】,【X:整数】,【V:整数】}とみなす
	X=X-1
	T=1なら
		ツリーでXにVを設定する
	他でT=2なら
		[ツリー:prod(X,V)]をコンソールに出力して改行する
	他なら
		関数2は『
			それを{【x:整数】}とみなす
			x<Vを返す
		』
		[(ツリー:max_right(X,関数2))+1]をコンソールに出力して改行する
	そして
そして

セグメントツリーとは
    -木:整数の固定長配列
    -葉の数:整数
    -本数:整数
    -実サイズ:整数
    -log:整数
    -単位元
    -評価関数:匿名手順

	はじめ(要素:整数の配列, 操作, 単位元)の手順
		【要素数】=要素の個数
		この単位元=単位元
		この評価関数=操作
		実サイズ=要素数
		log=2で要素数の対数を切り上げる
		葉の数=1をlogだけ左シフト
		本数=葉の数*2
		木=整数の配列(本数)を作ったもの
		木を単位元で埋める
		【i:整数】を葉の数から葉の数+要素数-1まで増やしながら繰り返す
			木#i=要素#(i-葉の数)。
		そして
		【i】を葉の数-1から1まで減らしながら繰り返す
			iで更新する
		そして
	終わり

    【k】で更新する手順
		木#k=評価関数を{(木#[2*k]),(木#[2*k+1])}で実行したもの
    終わり

	自分で【p:整数】に【x】を、設定する手順
		p=p+葉の数
		木#p=x
		【i】に1からlogまで繰り返す
			(pをiだけ右シフト)で更新する
		そして
	終わり

    自分から【p:整数】を、取得する手順
        木#[p+葉の数]を返す
    終わり

    prod_all()手順
        木#1を返す
    終わり

	prod(from:整数,to:整数)手順
		【sml】=単位元
		【smr】=単位元
		from=from+葉の数
		to=to+葉の数
		from<toの間繰り返す
			(fromと1の論理積)なら
				sml=評価関数を{sml, (木#from)}で実行したもの
				from=from+1
			そして
			(toと1の論理積)なら
				to=to-1
				smr=評価関数を{(木#to), smr}で実行したもの
			そして
			from=fromを1だけ右シフト
			to=toを1だけ右シフト
		そして

		評価関数を{sml, smr}で実行したものを返す
	終わり

	max_right(l:整数, fn)の手順:整数
		l=実サイズなら実サイズを返す
		l=l+葉の数
		【sm】=単位元
		繰り返す
			(l%2=0)の間繰り返す
				l=lを1だけ右シフト
			そして
			【R1:真偽値】=fnを{[評価関数を{sm, (木#l)}で実行したもの]}で実行したもの
			R1でないなら
				(l<葉の数)の間繰り返す
					l=lを1だけ左シフト
					R1=fnを{[評価関数を{sm, (木#l)}で実行したもの]}で実行したもの
					R1なら
						sm=評価関数を{sm, (木#l)}で実行したもの
						l=l+1
					そして
				そして
				l-葉の数を返す
			そして
			sm=評価関数を{sm, (木#l)}で実行したもの
			l=l+1
			((lと(-l)の論理積)=l)なら出る
		そして
		実サイズを返す
	終わり

	min_left(r:整数, fn)の手順:整数
		r=0なら0を返す
		r=r+葉の数
		sm=単位元
		繰り返す
			r=r-1
			(r%2)かつr>1の間繰り返す
				r=rを1だけ右シフト
			そして
			【R1:真偽値】=fnを{[評価関数を{(木#r), sm}で実行したもの]}で実行したもの
			R1でないなら
				(r<葉の数)の間繰り返す
					r=r*2+1
					R1=fnを{[評価関数を{(木#r), sm}で実行したもの]}で実行したもの
					R1なら
						sm=評価関数を{(木#r), sm}で実行したもの
						r=r-1
					そして
				そして
				r-葉の数+1を返す
			そして
			sm=評価関数を{(木#r), sm}で実行したもの
			((rと(-r)の論理積)=r)なら出る
		そして
		0を返す
	終わり
終わり
