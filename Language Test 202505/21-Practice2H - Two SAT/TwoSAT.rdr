//https://github.com/utopiat-ire/AtCoder.Produire
※コンソール
※コンパイル
コンソールから受け取って「 」で区切って{【N:整数】,【D:整数】}とみなす
Xという整数の配列(N)を作る
Yという整数の配列(N)を作る

番号に1からNまで繰り返す
	コンソールから受け取って「 」で区切って{X(番号),Y(番号)}とみなす
そして
問題という二充足可能性問題(N)を作る
木に1からNまでカウントしながら繰り返す
	林に木+1からNまでカウントしながら繰り返す
		(X(木)-X(林))の絶対値がD未満なら
			問題に木-1と林-1を1で追加する
		そして
		(X(木)-Y(林))の絶対値がD未満なら
			問題に木-1と林-1を2で追加する
		そして
		(Y(木)-X(林))の絶対値がD未満なら
			問題に木-1と林-1を3で追加する
		そして
		(Y(木)-Y(林))の絶対値がD未満なら
			問題に木-1と林-1を4で追加する
		そして
	そして
そして

問題の充足でなければ
	「No」をコンソールに出力して改行する
他なら
	「Yes」をコンソールに出力して改行する
	解答=問題の解答
	番号に1からNまで繰り返す
		解答(番号)なら
			X(番号)をコンソールに出力して改行する
		他なら
			Y(番号)をコンソールに出力して改行する
		そして
	そして
そして

二充足可能性問題とは
    -n:整数
    +解答:真偽値の配列
    -scc

 	はじめ(n)の手順
		このnは、n
		解答という真偽値の配列(n)を作る
		sccとして強連結成分グラフ(2*n)を作る
    終わり

    自分に【i:整数】と【j:整数】を【f:整数】で、追加する手順
    		【df】=0
    		fが3またはfが4ならdf=1
    		【dg】=0
    		fが2またはfが4ならdg=1
		scc:(2*i+(1-df))から(2*j+dg)へ頂点追加する
		scc:(2*j+(1-dg))から(2*i+df)へ頂点追加する
    終わり

	充足を求める手順:真偽値
		【結果】=sccの強連結成分
		【ids】=結果(2)
		【i】に0からn-1まで繰り返す
			ids#[2*i]=(ids#[2*i+1])なら
				×を返す
			そして
			解答#i=(ids#[2*i])<(ids#[2*i+1])
		そして
		○を返す
    終わり
終わり

強連結成分グラフとは
	-n:整数
	-edges:整数の配列の配列={}
	-start:整数の固定長配列
	-elist:整数の固定長配列

	はじめ(n)の手順
		このnは、n
	終わり

	【from:整数】から【to:整数】へ頂点追加する手順
		edgesに{from, to}を加える
	終わり

	再構成する手順
		startという整数の配列(n+1)を作る
		【counter:整数の固定長配列】という整数の配列(n+1)を作る
		edgesを【e:整数の配列】にそれぞれ繰り返す
			start#[(e#0)+1]=(start#[(e#0)+1])+1
		そして
		【辺数】=0
		【i】に1からnまで繰り返す
			start#iは(start#i)+(start#[i-1])
			counter#iは(start#i)
			辺数が(counter#i)より小さければ辺数=(counter#i)
		そして
		elistという整数の配列(辺数)を作る
		edgesを【e:整数の配列】にそれぞれ繰り返す
			elist#[counter#(e#0)]=(e#1)
			counter#(e#0)=(counter#(e#0))+1
		そして
	終わり

	-visited:整数のスタック
	-ord:整数の固定長配列
	-low:整数の固定長配列
	-ids:整数の固定長配列
	-【v:整数】を →【now_ord:整数】と→【group_num:整数】でdfsする手順
		low#v=now_ord
		ord#v=now_ord
		now_ord=now_ord+1
		visitedへvを積む
		【i】をstart#vから(start#[v+1])-1まで増やしながら繰り返す
			【to】=(elist#i)
			ord#to=-1なら
				toをnow_ordとgroup_numでdfsする
				low#vがlow#toより大きければ、low#v=(low#to)
			他なら
				low#vがord#toより大きければ、low#(v)=(ord#to)
			そして
		そして
		low#v=(ord#v)なら
			繰り返す
				【u:整数】=visitedから取り出す
				ord#u=n
				ids#u=group_num
				u=vなら
					出る
				そして
			そして
			group_num=group_num+1
		そして
	終わり
	強連結成分を求める手順:配列
		再構成する
		【now_ord】=0
		【group_num:整数】=0
		visitedという整数のスタックを作る
		lowという整数の配列(n)を作る
		idsという整数の配列(n)を作る
		ordという整数の配列(n)を作る
		【i】に1からnまで繰り返す
			ord(i)=-1
		そして
		【i:整数】に0からn-1まで繰り返す
			ord#i=-1なら
				iをnow_ordとgroup_numでdfsする
			そして
		そして
		【番号】に1からidsの個数まで繰り返す
			ids(番号)=group_num-1-ids(番号)
		そして
		{group_num, ids}を返す
	終わり

	頂点リストを求める手順:配列
		【結果:配列】=強連結成分
		【group_num:整数】=(結果#0)
		【counts】という整数の配列(group_num)を作る
		【groups】という整数の配列の配列(group_num)を作る
		【番号】に1からgroup_numまで繰り返す
			groups(番号)={}
		そして
		結果(2)を【x:整数】にそれぞれ繰り返す
			counts#x=(counts#x)+1
		そして
		【i】に0からn-1まで繰り返す
			(groups#(結果(2)#i))の1番目にiを挿入する
		そして
		groupsを返す
	終わり
終わり
