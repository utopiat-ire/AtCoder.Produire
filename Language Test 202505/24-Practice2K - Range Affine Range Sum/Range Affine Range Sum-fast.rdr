//https://github.com/utopiat-ire/AtCoder.Produire
※コンソール
※コンパイル
コンソールから受け取って「 」で区切って{【N:整数】,【Q:整数】}とみなす
コンソールから受け取って「 」で区切って【A:長整数の配列】とする

【i:整数】を1からAの個数まで増やしながら繰り返す
	A(i)=(A(i)<<32)+1
そして

ツリーという遅延評価セグメント木(A)を作る
ans={}
Q回繰り返す
	コンソールから受け取って「 」で区切って{【T:整数】,【L:整数】,【R:整数】,【C:長整数】,【D:長整数】}とみなす
	T=0なら
		ツリーをLからRまで(C<<32)+Dに更新する
	他なら
		ansに[(ツリーでLからRまで取得したもの)>>32]を追加する
	そして
そして
ansを改行で繋げたものをコンソールに出力して改行する


遅延評価セグメント木とは
	-木:長整数の固定長配列
	-lz:長整数の固定長配列
	-葉の数:長整数
	-本数:長整数
	-height:整数
	-MOD:長整数=998244353
	-identity:長整数=-1
	-単位元=-1
	-max:長整数

	はじめ(要素:長整数の配列)の手順
		【要素数:整数】=要素の個数
		【値:長整数】=1
		max=(値<<32)-1
		height=2で要素数の対数を切り上げる
		葉の数=1<<height
		本数=葉の数*2-1
		lz=長整数の配列(本数+1)を作る
		lzをidentityで埋める
		木=長整数の配列(葉の数*2)を作ったもの
		木を単位元で埋める
		【i】を葉の数から葉の数+要素数-1まで増やしながら繰り返す
			木#(i)=要素#(i-葉の数)
		そして
		【i】を葉の数-1から1まで減らしながら繰り返す
			木#[i]=演算((木#[i*2]), (木#[i*2+1]))
		そして
	終わり

	演算(a:長整数, b:長整数)の手順:長整数
		aが単位元ならbを返す
		bが単位元ならaを返す
		【plus】=a+b
		【ans】= (((plus>>32)%MOD)<<32)+(plus∧max)
		ansを返す
	終わり

	【id:整数】を作用させる手順
		lz#[id]がidentityなら返す

		【lza】=(lz#[id])>>32
		【lzb】=(lz#[id])∧max
		【tra】=(木#[id])>>32
		【trb】=(木#[id])∧max
		木#[id]=((((lza*tra)%MOD+((lzb*trb)%MOD))%MOD)<<32)+trb
		【next_lazy】=lz#[id]
		idが葉の数未満なら
			next_lazyでid*2を合成する
			next_lazyでid*2+1を合成する
		そして
		lz#[id]=identity
	終わり

	【add_lazy】で【id:整数】を合成する手順
		add_lazyが-1なら返す
		lz#[id]がidentityなら
			lz#[id]=add_lazy
			返す
		そして
		【lza】=lz#[id]>>32
		【lzb】=(lz#[id])∧max
		【adda】=add_lazy>>32
		【addb】=add_lazy∧max
		lz#[id]=(((lzb*adda+addb)%MOD)+((lza*adda%MOD)<<32))
	終わり

	【id:整数】の要素数を求める手順:長整数
		2<<(height-[2で(id+1)の対数を切り上げる])を返す
	終わり

	自分を【a:整数】から【b:整数】まで【x:長整数】に、更新する手順
		【l】=a+葉の数
		【r】=b+葉の数-1
		【i】をheightから1まで減らしながら繰り返す
			(((l>>i)<<i)=l)でないなら(l>>i)を作用させる
			((((r-1)>>i)<<i)=r)でないなら((r)>>i)を作用させる
		そして
		r=r+1
		繰り返す
			l<rでなければ出る
			l∧1が0でないなら
				xでlを合成する
				lを作用させる
				l=l+1
			そして
			r∧1が0でないなら
				r=r-1
				xでrを合成する
				rを作用させる
			そして
			l=l>>1
			r=r>>1
		そして
		l=a+葉の数
		r=b+葉の数-1
		【i】を1からheightまで増やしながら繰り返す
			【lt】=l>>i
			(lt<<i)がlでないなら
				lt*2を作用させる
				lt*2+1を作用させる
				木#[lt]=演算((木#[lt*2]), (木#[lt*2+1]))
			そして
			【rt】=r>>i
			(((r-1)>>i)<<i)がrでないなら
				rt*2を作用させる
				rt*2+1を作用させる
				木#[rt]=演算((木#[rt*2]), (木#[rt*2+1]))
			そして
		そして
	終わり

	自分で【a:整数】から【b:整数】まで、取得する手順:長整数
		【l】=a+葉の数
		【r】=b+葉の数-1
		繰り返す
		【i】をheightから1まで減らしながら繰り返す
			((l>>i)<<i)がlでないなら(l>>i)を作用させる
			(((r-1)>>i)<<i)がrでないなら(r>>i)を作用させる
		そして
		【vl】=単位元
		【vr】=単位元
		r=r+1
		繰り返す
			l<rでなければ出る
			(l∧1)が0でないなら
				lを作用させる
				vl=演算(vl, (木#[l]))
				l=l+1
			そして
			(r∧1)が0でないなら
				r=r-1
				rを作用させる
				vr=演算((木#[r]), vr)
			そして
			l=l>>1
			r=r>>1
		そして
		演算(vl, vr)を返す
	終わり

終わり

