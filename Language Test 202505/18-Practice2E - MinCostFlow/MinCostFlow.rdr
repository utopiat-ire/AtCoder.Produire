//https://github.com/utopiat-ire/AtCoder.Produire
※コンパイル
※コンソール
コンソールで聞いて「 」で区切って{【N:整数】,【K:整数】}とみなす

フローという最小フロー(N*2+2)を作る
INT_MAX=2147483647
【BIG:長整数】=1000000000
【s】=N*2
【t】=N*2+1

フロー:add_edge(s, t, N*K, BIG)

【i】に0からN-1まで繰り返す
	フロー:add_edge(s, i, K, 0)
	フロー:add_edge(N+i, t, K, 0)
そして

【tmp】={}
【解答:文字列の固定長配列の配列】={}
【i】に0からN-1まで繰り返す
	コンソールで聞いて「 」で区切ってtmp#[i]とする
	【item】=文字列の配列(N)を作る
	itemを「.」で埋める
	解答にitemを追加する
	【j】に0からN-1まで繰り返す
		vl=(tmp#i)#j
		フロー:add_edge(i, N+j, 1, BIG-vl)
	そして
そして
【結果】=フロー:flow(s, t, N*K)

N*K*BIG-結果#1をコンソールに出力して改行

【edges】=フロー:edges()
edgesをeにそれぞれ繰り返す
	(e#[0]=s または e#[1]=t または e#[3]=0)なら
		続ける
	そして
	(解答#[e#[0]])#[e#[1]-N]=「X」
そして

解答を行にそれぞれ繰り返す
	行を繋げたものをコンソールに出力して改行
そして

最小フローとは
	-n:整数
	-g:長整数の配列の配列の配列
	-位置:整数の配列の配列={}

	はじめ(n:整数)の手順
		このnは、n
		g=整数の配列の配列(n)を作る
		【i】に1からnまで繰り返す
			g(i)={}
		そして
	終わり

	add_edge(from:整数, to:整数, cap:長整数, cost:長整数)の手順:整数
		【m】=位置の個数
		位置に{from, (g#[from])の個数}を追加する
		g#[from]に{to, (g#[to])の個数, cap, cost}を追加する
		g#[to]に{from, (g#[from])の個数-1, 0, -cost}を追加する
		mを返す
	終わり

	get_edge(n:整数)の手順:長整数の配列
		【e】=(g#[(位置#n)#0])#[(位置#n)#1]
		【re】=(g#[e#0])#[e#1]
		{((位置#n)#0), (e#0), (e#2+re#2), (re#2), e#3}を返す
	終わり

	edges()の手順:長整数の配列の配列
		【結果:長整数の配列の配列】={}
		【i】に0から(位置の個数-1)まで繰り返す
			結果にget_edge(i)を追加する
		そして
		結果を返す
	終わり

	flow(s:整数, t:整数, limit:整数)の手順:配列
		【結果】=slope(s, t, limit)
		結果の末尾を返す
	終わり

	slope(s:整数, t:整数, limit:整数)の手順:配列
		【dual】=整数の配列(n)を作る
		【pv】=整数の配列(n)を作る
		【pe】=整数の配列(n)を作る
		【dual_ref】=『
			【dist】=整数の配列(n)を作る
			distをINT_MAXで埋める
			pvを-1で埋める
			peを-1で埋める
			【vis】=真偽値の配列(n)を作る
			visを×で埋める
			【que】という整数の優先度キューを作る
			dist#[s]=0
			queにsを0で入れる
			(queの要素数が1以上)の間繰り返す
				queから取り出して【v】とする
				(vis#[v])なら続ける
				vis#[v]=○
				vがtなら出る
				【i】に0から((g#v)の個数-1)まで繰り返す
					e=(g#[v])#[i]
					(vis#[e#[0]] または e#[2]=0)なら、続ける
					【cost】=(e#3)-(dual#[e#0])+(dual#[v])
					(dist#[e#0]-dist#v>cost)なら
						dist#[e#0]=dist#[v]+cost
						pv#[e#0]=v
						pe#[e#0]=i
						queにe#0を(INT_MAX-dist#[e#0])で入れる
					そして
				そして
			そして
			vis#[t]でないなら×を返す
			【v】に0からn-1まで繰り返す
				vis#[v]でないなら続ける
				dual#[v]=dual#[v]-(dist#[t]-dist#[v])
			そして
			○を返す
		』
		【flow】=0
		【cost:長整数】=0
		【prev_cost:長整数】=-1
		【結果】={}
		結果に{flow, cost}を追加する
		(flow<limit)の間繰り返す
			(dual_refを実行したもの)でないなら出る
			【c:長整数】=limit-flow
			【v】=t
			vがsでない間、繰り返す
				c=cと(((g#[pv#v])#[pe#v])#2)で小さい方
				v=pv#v
			そして
			v=t
			vがsでない間、繰り返す
				【e】=(g#[pv#v])#[pe#v]
				e#2=e#2-c
				((g#v)#[e#1])#2=((g#v)#[e#1])#2+c
				v=pv#[v]
			そして
			【d:長整数】=-dual#s
			flow=flow+c
			cost=cost+(c*d)
			(prev_cost=d)なら
				結果から(結果の個数)番目を消す
			そして
			結果に{flow, cost}を追加する
			prev_cost=cost
		そして
		結果を返す
	終わり
終わり

【A:整数】と【B:整数】で小さい方の手順
	AがBより小さければAを返す
	Bを返す
終わり
【A:整数】と【B:整数】で大きい方の手順
	AがBより大きければAを返す
	Bを返す
終わり
