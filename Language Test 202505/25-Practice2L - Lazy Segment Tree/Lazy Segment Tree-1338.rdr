//https://github.com/utopiat-ire/AtCoder.Produire
※コンソール
※コンパイル
コンソールから受け取って「 」で区切って{【N:整数】,【Q:整数】}とみなす
コンソールから受け取って「 」で区切って【A:長整数の配列】とする

【V:配列】={}
【i:整数】を1からNまで増やしながら繰り返す
	A(i)が1なら値=1。でなければ値=0
	V(i)={「len」=1,「one」=値,「inv」=0}
そして

op関数は『
	それを{【l】,【r】}とみなす
	【nLen:整数】= l(「len」)+r(「len」)
	【nOne:整数】= l(「one」)+r(「one」)
	【nInv:整数】= l(「inv」)+r(「inv」)+(r(「len」)-r(「one」))*l(「one」)
	{「len」=nLen,「one」=nOne,「inv」=nInv}を返す
』
mapping関数は『
	それを{【f】,【x】}とみなす
	fが0以外なら
		{「len」=x(「len」),
		「one」=x(「len」)-x(「one」), 
		「inv」=((x(「len」)-x(「one」))*x(「one」))-x(「inv」)
		}を返す
	他なら
	    xを返す
	そして
』
composition関数は『
	それを{【f】,【g】}とみなす
	f⊕gを返す
』
e関数は『
	{「len」=0,「one」=0,「inv」=0}を返す
』
id関数は『
	0を返す
』

ツリーという遅延評価セグメント木(V,e関数,op関数,mapping関数,composition関数,id関数)を作る
Q回繰り返す
	コンソールから受け取って「 」で区切って{【T:整数】,【L:整数】,【R:整数】}とみなす
	T=1なら
		ツリーでL-1からRまで1を適用する
	他なら
		(ツリーでL-1からRまでクエリする)(「inv」)をコンソールに出力して改行する
	そして
そして


遅延評価セグメント木とは
	-木:固定長配列
	-lz:固定長配列
	-葉の数:整数
	-本数:整数
	-log:整数
	-MOD:長整数=998244353
	-max:長整数
	-op関数:匿名手順
	-mapping関数:匿名手順
	-composition関数:匿名手順
	-e関数:匿名手順
	-id関数:匿名手順

	はじめ(要素:配列,e関数,op関数,mapping関数,composition関数,id関数)の手順
		【要素数】=要素の個数
		【値:長整数】=1
		このop関数=op関数
		このmapping関数=mapping関数
		このcomposition関数=composition関数
		このe関数=e関数
		このid関数=id関数
		max=(値<<32)-1
		log=2で要素数の対数を切り上げる
		葉の数=1<<log
		本数=葉の数*2-1
		木=固定長配列(葉の数*2)を作ったもの
		【i:整数】を1から葉の数*2まで増やしながら繰り返す
			木(i)=単位元
		そして
		lz=整数の配列(葉の数)を作る
		【i:整数】を1から葉の数まで増やしながら繰り返す
			lz(i)=恒等写像
		そして
		【i:整数】を0から要素数-1まで増やしながら繰り返す
			木#(葉の数+i)=要素#i
		そして
		【i:整数】を葉の数-1から1まで減らしながら繰り返す
			iを更新する
		そして
	終わり

	-op(l,r)手順
		op関数を{l,r}で実行して返す
	終わり
	-mapping(f,x)手順
		mapping関数を{f,x}で実行して返す
	終わり
	-composition(f,g)手順
		composition関数を{f,g}で実行して返す
	終わり
	-単位元を取得する手順
		e関数を実行して返す
	終わり
	-恒等写像を取得する手順
		id関数を実行して返す
	終わり

	【k:整数】を更新する手順
		木#k=op((木#[2*k]),(木#[2*k+1]))
	終わり

	【id:整数】の要素数を求める手順:整数
		2<<(log-[2で(id+1)の対数を切り上げる])を返す
	終わり

	自分で【l:整数】から【r:整数】まで、クエリする手順
		lがr以上なら単位元を返す
		l=l+葉の数
		r=r+葉の数
		【i:整数】をlogから1まで減らしながら繰り返す
			(((l>>i)<<i)=l)でないなら(l>>i)に加える
			(((r>>i)<<i)=r)でないなら((r-1)>>i)に加える
		そして

		【sml】=単位元
		【smr】=単位元
		(l<r)の間繰り返す
			(l∧1)が0でないなら
				sml=op(sml, (木#l))
				l=l+1
			そして
			(r∧1)が0でないなら
				r=r-1
				smr=op((木#r), smr)
			そして
			l=l>>1
			r=r>>1
		そして
		//木すべてをダンプしたものすべてを報告
		op(sml, smr)を返す
	終わり

	+【p:整数】に【ノード】を、適用する手順
		p=p+葉の数
		【i:整数】をlogから1まで減らしながら繰り返す
			(p>>i)に加える
		そして
		木#[p]=mapping(ノード, 木#[p])
		【i:整数】を1からlogまで増やしながら繰り返す
			(p>>i)を更新する
		そして
	終わり

	自分で【a:整数】から【b:整数】まで【f】を適用する手順
		aがb以上なら返す
		【l】=a+葉の数
		【r】=b+葉の数

		【i:整数】をlogから1まで減らしながら繰り返す
		    (((l>>i)<<i)=l)でないなら(l>>i)に加える
		    (((r>>i)<<i)=r)でないなら((r-1)>>i)に加える
		そして

		【l2】=l
		【r2】=r
		l<rの間、繰り返す
			(l∧1)が0でないなら
				lにfをすべて適用する
				l=l+1
			そして
			(r∧1)が0でないなら
				r=r-1
				rにfをすべて適用する
			そして
			l=l>>1
			r=r>>1
		そして
		l=l2
		r=r2

		【i:整数】を1からlogまで増やしながら繰り返す
			(((l>>i)<<i)=l)でないなら(l>>i)を更新する
			(((r>>i)<<i)=r)でないなら((r-1)>>i)を更新する
		そして
	終わり

	自分を【l:整数】から【r:整数】まで、ダンプする手順
		lからrまでクエリして【結果】とする
		「[[][l],[r][]]  [結果をダンプする]」を報告する
	終わり
	自分をダンプする手順
		【i:整数】を1から葉の数まで増やしながら繰り返す
			【v】=木(葉の数+i)
			「{ len: [v(「len」)], one: [v(「one」)], inv: [v(「inv」)] }」を報告
		そして
	終わり
	-【k:整数】に【f】をすべて適用する手順
		木#[k]=mapping(f, 木#[k])
		(k<葉の数)ならlz#[k]=composition(f, lz#[k])
	終わり
	-【k:整数】に、加える手順
		(2*k)にlz#[k]をすべて適用する
		(2*k+1)にlz#[k]をすべて適用する
		lz#[k]=恒等写像
	終わり

終わり

【v】をダンプする手順
	「{ len: [v(「len」)], one: [v(「one」)], inv: [v(「inv」)] }」を返す
終わり
